#ifndef FDF_H
# define FDF_H
# include "libft.h"
# include <errno.h>
# include <math.h>
# include <fcntl.h>
# include "mlx.h"
# include <time.h>

typedef	struct		s_point
{
	int				z;
	int				color;
}					t_point;

typedef struct		s_conv
{
	double			zoom;
	double			pos_x;
	double			pos_y;
	double			angle_x;
	double			angle_y;
}					t_conv;

typedef struct		s_mlx
{
	void			*web;
	t_conv			*conv;
	void			*mlx_ptr;
	void			*win;
	void			*img;
	char			*data;
	int				web_x;
	int				web_y;
	int				bpp;
	int				linesize;
	int				endian;
	int				projection;
}					t_mlx;

typedef struct		s_bresenham
{
	int				dx;
	int				dy;
	int				sx;
	int				sy;
	int				err;
	int				e2;
}					t_bresenham;

typedef struct		s_xy
{
	int				x;
	int				y;
}					t_xy;

char				*fdf_reader_checker(const char *file, int *y, int *x);
void				fdf_parser(const int y, const int x, t_point web[y][x], \
					const char *read);
void				fdf_painter(const int y, const int x, t_point web[y][x]);
long				errors(const int err, const char *name);
void				put_pixel(t_mlx *mlx, int x, int y, int color);
void				put_line(t_mlx *mlx, t_xy a, t_xy b, int color);
void				painter(t_mlx *mlx);
void				cleaner(t_mlx *mlx);
int					mouse(int button, int x, int y, void *param);
int					keys(int keycode, void *param);
void				zoom(t_mlx *mlx);
void				unzoom(t_mlx *mlx);
int					get_colorful(t_mlx *mlx, int x_count, int y_count);

# define WIN_NAME "fdf"
# define WIN_W 1024
# define WIN_H 632
# define IMG_W WIN_W + 200
# define IMG_H WIN_H + 200

# define DEFAULT_COLOR 0x00ff00

# define Z ((*web)[y_count][x_count]).z
# define COLOR ((*web)[y_count][x_count]).color
# define ZOOM ((t_conv*)(mlx->conv))->zoom
# define POS_X ((t_conv*)(mlx->conv))->pos_x
# define POS_Y ((t_conv*)(mlx->conv))->pos_y
# define ANGLE_X ((t_conv*)(mlx->conv))->angle_x
# define ANGLE_Y ((t_conv*)(mlx->conv))->angle_y
# define XPUT (x_count + Z * ANGLE_X / 42) * ZOOM
# define YPUT (y_count + Z * ANGLE_Y / 42) * ZOOM
# define XISO XPUT - YPUT
# define YISO (XPUT + YPUT) / 2

#endif

fdf
#include "fdf.h"

static void		overmind(const char *read, const int y, const int x)
{
	t_point		web[y][x];
	int			y_count;
	int			x_count;

	y_count = -1;
	while (++y_count < y && (x_count = -1))
		while (++x_count < x)
		{
			web[y_count][x_count].z = 0;
			web[y_count][x_count].color = DEFAULT_COLOR;
		}
	fdf_parser(y, x, web, read);
	ft_memdel((void**)&read);
	fdf_painter(y, x, web);
}

int				main(int ac, char **av)
{
	int			y;
	int			x;
	char		*read;

	x = 0;
	y = 0;
	if (ac > 1)
	{
		if (!(read = fdf_reader_checker(av[1], &y, &x)))
			errors(3, av[1]);
		else
			overmind(read, y, x);
	}
	else
		errors(1, 0);
	return (0);
}

long			errors(const int err, const char *name)
{
	ft_putstr_fd("fdf: ", 2);
	if (name)
	{
		ft_putstr_fd(name, 2);
		ft_putstr_fd(" ", 2);
	}
	if (err == 0)
		ft_putendl_fd(strerror(errno), 2);
	else if (err == 1)
		ft_putstr_fd("\nUsage: fdf [file]\n", 2);
	else if (err == 2)
		ft_putstr_fd("\n", 2);
	else if (err == 3)
		ft_putstr_fd(" : Invalid map\n", 2);
	exit(1);
	return (0);
}

brush
#include "fdf.h"

int					get_colorful(t_mlx *mlx, int x_count, int y_count)
{
	int				color;

	t_point(*web)[mlx->web_y][mlx->web_x];
	web = mlx->web;
	color = DEFAULT_COLOR;
	if (COLOR != DEFAULT_COLOR)
		color = COLOR;
	if (++x_count < mlx->web_x)
		if (COLOR != DEFAULT_COLOR)
			color = COLOR;
	x_count--;
	if (++y_count < mlx->web_y)
		if (COLOR != DEFAULT_COLOR)
			color = COLOR;
	y_count -= 2;
	if (y_count > 0)
		if (COLOR != DEFAULT_COLOR)
			color = COLOR;
	y_count++;
	x_count--;
	if (x_count > 0)
		if (COLOR != DEFAULT_COLOR)
			color = COLOR;
	return (color);
}

void				put_pixel(t_mlx *mlx, int x, int y, int color)
{
	int				i;

	if (x >= IMG_W || y >= IMG_H || x < 0 || y < 0)
	{
		ft_printf("x = %d, y = %d\n", x, y);
		return ;
		errors(2, "Out of bounds");
	}
	i = mlx->linesize * y + x * (mlx->bpp / 8);
	mlx->data[i] = color & 0xff;
	mlx->data[++i] = color >> 8 & 0xff;
	mlx->data[++i] = color >> 16;
}

void				put_line(t_mlx *mlx, t_xy a, t_xy b, int color)
{
	t_bresenham		badass;

	badass.dx = abs(b.x - a.x);
	badass.sx = a.x < b.x ? 1 : -1;
	badass.dy = abs(b.y - a.y);
	badass.sy = a.y < b.y ? 1 : -1;
	badass.err = (badass.dx > badass.dy ? badass.dx : -badass.dy) / 2;
	badass.e2 = badass.err;
	while (1)
	{
		put_pixel(mlx, a.x, a.y, color);
		if (a.x == b.x && a.y == b.y)
			break ;
		badass.e2 = badass.err;
		if (badass.e2 > -badass.dx)
		{
			badass.err -= badass.dy;
			a.x += badass.sx;
		}
		if (badass.e2 < badass.dy)
		{
			badass.err += badass.dx;
			a.y += badass.sy;
		}
	}
}

parser
void			fdf_parser(const int y, const int x, t_point web[y][x], \
					const char *read)
{
	int		y_count;
	int		x_count;

	y_count = -1;
	while (++y_count < y && (x_count = -1))
	{
		while (++x_count < x)
		{
			while (*read != '\n' && (*read == ' ' || *read == '\t'))
				read++;
			web[y_count][x_count].z = ft_atoi(read);
			while (*read != '\n' && (ft_isdigit(*read) || *read == '-'))
				read++;
			if (*read == ',')
			{
				read++;
				web[y_count][x_count].color = ft_atoi_base(read, 16);
				while (*read != '\n' && ft_strchr("xABCDEF1234567890", *read))
					read++;
			}
			read++;
		}
	}
}

static int		count_numbers(char *line, int x)
{
	while (*line)
	{
		while (*line && (*line == ' ' || *line == '\t'))
			line++;
		if (*line && *line == '-')
			line++;
		if (*line)
		{
			if (ft_isdigit(*line))
				x++;
			else
				return (-1);
		}
		while (*line && ft_isdigit(*line))
			line++;
		if (*line == ',')
		{
			line++;
			while (*line && (ft_isdigit(*line) || ft_strchr("xABCDEF", *line)))
				line++;
		}
	}
	return (x);
}

static char		*joiner(char *read, char *line)
{
	char		*tmp_read;
	char		*tmp_line;
	char		*new;
	size_t		len;

	tmp_read = read;
	tmp_line = line;
	len = ft_strlen(line);
	while (--len && (line[len] == ' ' || line[len] == '\t'))
		line[len] = 0;
	new = ft_strnjoin(3, (read ? read : ""), line, "\n");
	if (tmp_read)
		free(tmp_read);
	free(tmp_line);
	return (new);
}

char			*fdf_reader_checker(const char *file, int *y, int *x)
{
	char	*line;
	char	*read;
	int		fd;
	int		status;
	int		countx;

	read = NULL;
	status = 1;
	if (((fd = open(file, O_RDONLY)) || 1) && fd == -1)
		errors(0, file);
	line = NULL;
	while ((status = ft_get_next_line(fd, &line)) && status == 1)
	{
		countx = count_numbers(line, 0);
		if (!*y)
			*x = countx;
		else if (*x != countx || countx == -1)
			return (NULL);
		read = joiner(read, line);
		(*y)++;
	}
	if (status == -1)
		errors(0, 0);
	close(fd);
	return (read);
}

paint
static int			in_map(t_xy here)
{
	if (here.x >= IMG_W || here.y >= IMG_H || here.x < 0 || here.y < 0)
		return (0);
	return (1);
}

static t_xy			there(t_mlx *mlx, int x_count, int y_count)
{
	t_xy		there;
	t_point		(*web)[mlx->web_y][mlx->web_x];

	there = (t_xy){0, 0};
	web = mlx->web;
	if (mlx->projection == 1)
		there = (t_xy){XPUT + POS_X, YPUT + POS_Y};
	else if (mlx->projection == 2)
		there = (t_xy){XISO + POS_X, YISO + POS_Y};
	return (there);
}

void				painter(t_mlx *mlx)
{
	int			y_count;
	int			x_count;
	t_xy		here;
	t_point		(*web)[mlx->web_y][mlx->web_x];

	web = mlx->web;
	y_count = -1;
	while (++y_count < mlx->web_y && (x_count = -1))
		while (++x_count < mlx->web_x)
		{
			here = there(mlx, x_count, y_count);
			if (in_map(here))
			{
				put_pixel(mlx, here.x, here.y, (*web)[y_count][x_count].color);
				if (x_count + 1 < mlx->web_x && \
					in_map(there(mlx, x_count + 1, y_count)))
					put_line(mlx, here, there(mlx, x_count + 1, y_count), \
					get_colorful(mlx, x_count + 1, y_count));
				if (y_count + 1 < mlx->web_y && \
					in_map(there(mlx, x_count, y_count + 1)))
					put_line(mlx, here, there(mlx, x_count, y_count + 1), \
					get_colorful(mlx, x_count, y_count + 1));
			}
		}
	mlx_put_image_to_window(mlx->mlx_ptr, mlx->win, mlx->img, -100, -100);
}

void				cleaner(t_mlx *mlx)
{
	int			y_count;
	int			x_count;
	t_xy		here;
	t_point		(*web)[mlx->web_y][mlx->web_x];

	web = mlx->web;
	y_count = -1;
	while (++y_count < mlx->web_y && (x_count = -1))
		while (++x_count < mlx->web_x)
		{
			here = there(mlx, x_count, y_count);
			if (in_map(here))
			{
				put_pixel(mlx, here.x, here.y, 0);
				if (x_count + 1 < mlx->web_x && \
					in_map(there(mlx, x_count + 1, y_count)))
					put_line(mlx, here, there(mlx, x_count + 1, y_count), 0);
				if (y_count + 1 < mlx->web_y && \
					in_map(there(mlx, x_count, y_count + 1)))
					put_line(mlx, here, there(mlx, x_count, y_count + 1), 0);
			}
		}
}

void				fdf_painter(const int y, const int x, t_point web[y][x])
{
	t_mlx		mlx;
	t_conv		conv;

	ft_bzero(&conv, sizeof(t_conv));
	ft_bzero(&mlx, sizeof(t_mlx));
	mlx.conv = &conv;
	mlx.projection = 1;
	mlx.web_x = x;
	mlx.web_y = y;
	mlx.web = web;
	mlx.mlx_ptr = mlx_init();
	conv.zoom = (WIN_W / x > WIN_H / y ? WIN_H / y : WIN_W / x);
	conv.angle_x = -2;
	conv.angle_y = -2;
	conv.pos_x = 100;
	conv.pos_y = 100;
	mlx.win = mlx_new_window(mlx.mlx_ptr, WIN_W, WIN_H, WIN_NAME);
	mlx.img = mlx_new_image(mlx.mlx_ptr, IMG_W, IMG_H);
	mlx.data = mlx_get_data_addr(mlx.img, &(mlx.bpp), &(mlx.linesize), \
			&(mlx.endian));
	mlx_hook(mlx.win, 2, 3, keys, &mlx);
	mlx_mouse_hook(mlx.win, mouse, &mlx);
	painter(&mlx);
	mlx_loop(mlx.mlx_ptr);
}

mouse
void		zoom(t_mlx *mlx)
{
	ZOOM += 1;
}

void		unzoom(t_mlx *mlx)
{
	if (ZOOM > 1)
		ZOOM -= 1;
}

int			mouse(int button, int x, int y, void *param)
{
	ft_printf("mouse [x%d][y%d]: %d\n", x, y, button);
	cleaner(param);
	if (button == 4)
		zoom(param);
	else if (button == 5)
		unzoom(param);
	painter(param);
	return (0);
}

key
static void		reset(t_mlx *mlx)
{
	int			y_count;
	int			x_count;

	t_point(*web)[mlx->web_y][mlx->web_x];
	web = mlx->web;
	y_count = -1;
	while (++y_count < mlx->web_y && (x_count = -1))
		while (++x_count < mlx->web_x)
			COLOR = DEFAULT_COLOR;
	ZOOM = (WIN_W / mlx->web_x > WIN_H / mlx->web_y ? WIN_H / mlx->web_y : \
			WIN_W / mlx->web_x);
	POS_X = 100;
	POS_Y = 100;
	ANGLE_X = 0;
	ANGLE_Y = 0;
}

static void		colorise(t_mlx *mlx, int keycode)
{
	int			y_count;
	int			x_count;
	int			col;

	t_point(*web)[mlx->web_y][mlx->web_x];
	web = mlx->web;
	srand(time(NULL));
	col = rand();
	y_count = -1;
	while (++y_count < mlx->web_y && (x_count = -1))
		while (++x_count < mlx->web_x)
		{
			if (keycode == 49)
				COLOR = (COLOR + col) % 0xffffff + Z * 42;
			else
				COLOR = (COLOR + rand()) % 0xffffff;
		}
}

static void		position(t_mlx *mlx, int keycode)
{
	if (keycode == 126)
		POS_Y -= 10;
	if (keycode == 125)
		POS_Y += 10;
	if (keycode == 123)
		POS_X -= 10;
	if (keycode == 124)
		POS_X += 10;
}

static void		angle(t_mlx *mlx, int keycode)
{
	if (keycode == 13)
		ANGLE_Y -= 1;
	if (keycode == 1)
		ANGLE_Y += 1;
	if (keycode == 0)
		ANGLE_X -= 1;
	if (keycode == 2)
		ANGLE_X += 1;
	if (keycode == 18)
		mlx->projection = 1;
	if (keycode == 19)
		mlx->projection = 2;
}

int				keys(int keycode, void *param)
{
	ft_printf("keycode press = %d\n", keycode);
	cleaner(param);
	if (keycode == 53)
	{
		mlx_destroy_image(((t_mlx *)param)->mlx_ptr, ((t_mlx *)param)->img);
		mlx_destroy_window(((t_mlx *)param)->mlx_ptr, ((t_mlx *)param)->win);
		exit(1);
	}
	else if ((keycode <= 126) && (keycode >= 123))
		position(param, keycode);
	else if (((keycode >= 0) && (keycode <= 2)) || keycode == 13 || \
			keycode == 18 || keycode == 19)
		angle(param, keycode);
	else if (keycode == 78)
		unzoom(param);
	else if (keycode == 69)
		zoom(param);
	else if (keycode == 49 || keycode == 48)
		colorise(param, keycode);
	else if (keycode == 51)
		reset(param);
	painter(param);
	return (0);
}