#ifndef FDF_H
# define FDF_H

# include <math.h>
# include <fcntl.h>
# include <string.h>
# include <stdio.h>
# include <mlx.h>
# include "libft.h"
# define WIN_HEIGHT		1300
# define WIN_WIDTH		2350

/*
** -------------------------------- Struct -------------------------------------
*/

typedef struct	s_color
{
	int	r;
	int	g;
	int	b;
	int	decimal;
}				t_color;

typedef	struct	s_line_values
{
	int				height;
	struct s_color	*color;
}				t_line_values;

typedef struct	s_line
{
	struct s_line_values	**values;
	struct s_point			**points;
	int						size;
	int						num;
	struct s_line			*next;
}				t_line;

typedef struct	s_img
{
	void	*img_ptr;
	int		bpp;
	int		size_line;
	int		endian;
	int		*data;
}				t_img;

typedef struct	s_fdf
{
	void					*mlx;
	void					*win;
	struct s_img			*img;
	struct s_point			*spaces;
	struct s_line			*line;
	struct s_point			*translation;
	struct s_palette		*palette;
	int						coef_z;
}				t_fdf;

typedef struct	s_point
{
	int		x;
	int		y;
}				t_point;

typedef	struct	s_segment
{
	struct s_point	*d;
	struct s_point	*s;
}				t_segment;

typedef	struct	s_gradient
{
	struct s_color	*begin;
	struct s_color	*end;
	struct s_color	*color;
	int				nb_pixel;
	float			step;
	float			mix;
}				t_gradient;

typedef	struct	s_palette
{
	struct s_color	*c1;
	struct s_color	*c2;
	struct s_color	*c3;
	struct s_color	*c4;
	struct s_color	*c5;
}				t_palette;

/*
** -------------------------------- Parser -------------------------------------
*/

t_fdf			*check_valid_file(int fd, int ac, char **av);

/*
** --------------------------------- Line --------------------------------------
*/

t_line			*create_line(t_line_values **values, int num, int size);
t_line_values	*create_line_values(int height, t_color *color);

/*
** -------------------------------- Point --------------------------------------
*/
t_point			*create_point(int x, int y);
t_point			*copy_point(t_point *point);
void			set_point(t_point *point, int x, int y);

/*
** -------------------------------- Points -------------------------------------
*/
void			set_points(t_fdf *fdf);

/*
** -------------------------------- Segment ------------------------------------
*/
t_segment		*create_segment(int dx, int dy, int sx, int sy);
void			free_segment(t_segment *segment);

/*
** --------------------------------- MLX ---------------------------------------
*/

void			create_window(t_fdf *fdf, char *file_name);

/*
** --------------------------------- Event -------------------------------------
*/

int				mlx_key(int keycode, void *param);
int				mlx_zoom(int button, int x, int y, void *param);
int				mlx_key_pressed(int keycode, void *param);

/*
** ---------------------------------- FDF --------------------------------------
*/

t_fdf			*create_fdf(t_line *line, int ac, char **av);
int				get_max_line_size(t_fdf *fdf);

/*
** ---------------------------------- Draw -------------------------------------
*/

void			draw_points(t_fdf *fdf, t_point *tmp);
int				get_nb_pixel(t_point *a, t_point *b);
/*
** ----------------------------------- Img -------------------------------------
*/

t_img			*create_img(void *img, int color, int width, int height);

/*
** --------------------------------- Gradient ----------------------------------
*/

t_gradient		*create_gradient(t_color *beg, t_color *end, t_point *a,
									t_point *b);
void			free_gradient(t_gradient *gradient);

/*
** ---------------------------------- Color ------------------------------------
*/

t_color			*get_color(t_fdf *fdf, int n);
t_color			*create_color(int decimal);

/*
** --------------------------------- Palette -----------------------------------
*/

t_palette		*create_palette(int ac, char **av);

/*
** ---------------------------------- Error ------------------------------------
*/

void			malloc_error();
void			palette_error();
void			arg_error();
void			system_error();
void			map_error();
#endif

segment
#include "fdf.h"

t_segment	*create_segment(int dx, int dy, int sx, int sy)
{
	t_segment	*segment;

	if (!(segment = (t_segment*)ft_memalloc(sizeof(t_segment))))
		malloc_error();
	segment->d = create_point(dx, dy);
	segment->s = create_point(sx, sy);
	return (segment);
}

void		free_segment(t_segment *segment)
{
	(void)segment;
	ft_memdel((void**)&segment->d);
	ft_memdel((void**)&segment->s);
	ft_memdel((void**)&segment);
}

points
#include "fdf.h"

void	set_points(t_fdf *fdf)
{
	int				i;
	t_line			*line;
	t_point			*pos;
	t_point			*pos2;

	pos = create_point(fdf->translation->x, fdf->translation->y);
	pos2 = create_point(pos->x, pos->y);
	line = fdf->line;
	while (line)
	{
		i = 0;
		while (i < line->size)
		{
			set_point(line->points[i], pos->x,
					pos->y - line->values[i]->height * fdf->coef_z);
			set_point(pos, pos->x + fdf->spaces->x, pos->y - fdf->spaces->y);
			i++;
		}
		set_point(pos2, pos2->x + fdf->spaces->x, pos2->y + fdf->spaces->y);
		set_point(pos, pos2->x, pos2->y);
		line = line->next;
	}
	ft_memdel((void**)&pos);
	ft_memdel((void**)&pos2);
}

parser
#include "fdf.h"

static int		check_hexa(char *line)
{
	int	i;

	i = 0;
	line++;
	if (*line && *line != '0')
		map_error();
	line++;
	if (*line && *line != 'x')
		map_error();
	line++;
	while (*line && *line != ' ')
	{
		if ((*line < 'A' || *line > 'F') && (*line < 'a' || *line > 'f') &&
				(*line < '0' || *line > '9'))
			map_error();
		line++;
		i++;
	}
	if (i == 0 || i > 6)
		map_error();
	return (i);
}

static void		check_line_valid(char *line)
{
	while (*line)
	{
		while (*line && *line == ' ')
			line++;
		if (*line == '-')
			line++;
		if (!*line || *line < '0' || *line > '9')
			map_error();
		while (*line != '\0' && *line >= '0' && *line <= '9')
			line++;
		if (*line == '\0')
			break ;
		if (*line == ',')
			line += check_hexa(&(*line)) + 3;
		if (*line == '\0')
			break ;
		if (*line && *line != ' ')
			map_error();
		while (*line && *line == ' ')
			line++;
	}
}

static	t_color	*get_point_color(char *point)
{
	t_color	*color;
	char	*color_point;

	if (ft_strchr(point, ','))
	{
		color_point = &ft_strchr(point, ',')[1];
		color = create_color(ft_htoi(color_point));
	}
	else
		color = create_color(0);
	return (color);
}

static t_line	*line_to_struct(char *line)
{
	static int		num;
	char			**all_values;
	t_line_values	**values;
	int				size;
	int				size_cpy;

	all_values = ft_strsplit(line, ' ');
	size = 0;
	while (all_values[size])
		size++;
	size_cpy = size;
	if (!(values = (t_line_values**)ft_memalloc(sizeof(t_line_values*) * size)))
		malloc_error();
	while (size - 1 >= 0)
	{
		values[size - 1] = create_line_values(ft_atoi(all_values[size - 1]),
		get_point_color(all_values[size - 1]));
		ft_memdel((void**)&all_values[size - 1]);
		size--;
	}
	num++;
	ft_memdel((void**)&all_values);
	return (create_line(values, num, size_cpy));
}

t_fdf			*check_valid_file(int fd, int ac, char **av)
{
	char	*line;
	t_line	*line_struct_tmp;
	t_line	*line_struct;
	int		size;

	if (get_next_line(fd, &line) < 1)
		map_error();
	check_line_valid(line);
	line_struct_tmp = line_to_struct(line);
	line_struct = line_struct_tmp;
	size = line_struct_tmp->size;
	ft_memdel((void**)&line);
	while (get_next_line(fd, &line) == 1)
	{
		check_line_valid(line);
		line_struct_tmp->next = line_to_struct(line);
		if (size != line_struct_tmp->next->size)
			map_error();
		line_struct_tmp = line_struct_tmp->next;
		ft_memdel((void**)&line);
	}
	return (create_fdf(line_struct, ac, av));
}

palette
#include "fdf.h"

static int		check_hexa(char *line)
{
	int	i;

	i = 0;
	if (*line && *line != '0')
		palette_error();
	line++;
	if (*line && *line != 'x')
		palette_error();
	line++;
	while (*line && *line != ' ')
	{
		if ((*line < 'A' || *line > 'F') && (*line < 'a' || *line > 'f') &&
				(*line < '0' || *line > '9'))
			return (0);
		line++;
		i++;
	}
	if (i != 6)
		palette_error();
	return (1);
}

static	void	init_palette(t_palette *palette)
{
	palette->c1 = NULL;
	palette->c2 = NULL;
	palette->c3 = NULL;
	palette->c4 = NULL;
	palette->c5 = NULL;
}

t_palette		*create_palette(int ac, char **av)
{
	t_palette	*palette;
	int			i;

	i = 2;
	if (!(palette = (t_palette*)ft_memalloc(sizeof(t_palette))))
		malloc_error();
	init_palette(palette);
	while (i < ac)
	{
		if (i == 2 && check_hexa(av[i]) == 1)
			palette->c1 = create_color(ft_htoi(av[i]));
		if (i == 3 && check_hexa(av[i]) == 1)
			palette->c2 = create_color(ft_htoi(av[i]));
		if (i == 4 && check_hexa(av[i]) == 1)
			palette->c3 = create_color(ft_htoi(av[i]));
		if (i == 5 && check_hexa(av[i]) == 1)
			palette->c4 = create_color(ft_htoi(av[i]));
		if (i == 6 && check_hexa(av[i]) == 1)
			palette->c5 = create_color(ft_htoi(av[i]));
		i++;
	}
	return (palette);
}

mlx
#include "fdf.h"

static void	display_menu(t_fdf *fdf, char *file_name_split)
{
	t_img	*img;
	int		width;

	width = 300;
	img = create_img(mlx_new_image(fdf->mlx, width, WIN_HEIGHT),
			0x262626, width, WIN_HEIGHT);
	mlx_put_image_to_window(fdf->mlx, fdf->win, img->img_ptr, 0, 0);
	mlx_string_put(fdf->mlx, fdf->win, 80, 10, 0xFFFFFF, "FDF Controls");
	mlx_string_put(fdf->mlx, fdf->win, 10, 60, 0xFFFFFF, "Map:");
	mlx_string_put(fdf->mlx, fdf->win, 60, 60, 0xFFFFFF, file_name_split);
	mlx_string_put(fdf->mlx, fdf->win, 10, 90, 0xFFFFFF,
			"Translation: ^ v < >");
	mlx_string_put(fdf->mlx, fdf->win, 10, 120, 0xFFFFFF,
			"Zoom: MOUSE UP or MOUSE DOWN");
	mlx_string_put(fdf->mlx, fdf->win, 10, 150, 0xFFFFFF,
			"Zoom height: + or -");
	mlx_string_put(fdf->mlx, fdf->win, 10, 180, 0xFFFFFF, "Exit: ESC");
	mlx_string_put(fdf->mlx, fdf->win, 10, WIN_HEIGHT - 25, 0xFFFFFF,
			"Author: LEDRU Anthony");
	ft_memdel((void*)&img);
}

void		create_window(t_fdf *fdf, char *file_name)
{
	void	*mlx;
	void	*win;
	char	**file_name_split;

	if (!(mlx = mlx_init()))
		exit(EXIT_FAILURE);
	file_name_split = ft_strsplit(file_name, '/');
	while (*file_name_split)
		file_name_split++;
	file_name_split--;
	if (!(win = mlx_new_window(mlx, WIN_WIDTH, WIN_HEIGHT, *file_name_split)))
		exit(EXIT_FAILURE);
	fdf->mlx = mlx;
	fdf->win = win;
	fdf->img = create_img(mlx_new_image(fdf->mlx, WIN_WIDTH, WIN_HEIGHT),
			0x212121, WIN_WIDTH, WIN_HEIGHT);
	mlx_key_hook(win, mlx_key, fdf);
	mlx_hook(win, 2, 0, mlx_key_pressed, fdf);
	mlx_mouse_hook(win, mlx_zoom, fdf);
	set_points(fdf);
	draw_points(fdf, create_point(0, 0));
	display_menu(fdf, *file_name_split);
	mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->img->img_ptr, 300, 0);
	mlx_loop(mlx);
}

main
#include "fdf.h"

int		main(int ac, char **av)
{
	int			fd;
	t_fdf		*fdf;

	if (ac < 2 || ac > 7)
		arg_error();
	fd = open(av[1], O_RDONLY);
	if (fd == -1)
		system_error();
	fdf = check_valid_file(fd, ac, av);
	close(fd);
	create_window(fdf, av[1]);
	return (0);
}

line
#include "fdf.h"

t_line			*create_line(t_line_values **values, int num, int size)
{
	t_line	*line;
	int		i;

	i = 0;
	if (!(line = (t_line*)ft_memalloc(sizeof(t_line))))
		malloc_error();
	line->values = values;
	if (!(line->points = (t_point**)ft_memalloc(sizeof(t_point*) * size)))
		malloc_error();
	while (i < size)
	{
		line->points[i] = create_point(0, 0);
		i++;
	}
	line->num = num;
	line->size = size;
	line->next = NULL;
	return (line);
}

t_line_values	*create_line_values(int height, t_color *color)
{
	t_line_values *line_values;

	if (!(line_values = (t_line_values*)ft_memalloc(sizeof(t_line_values))))
		malloc_error();
	line_values->height = height;
	line_values->color = color;
	return (line_values);
}

img
#include "fdf.h"

static void	fill_img(t_img *img, int color, int width, int height)
{
	int i;

	i = 0;
	while (i < height * width)
	{
		img->data[i] = color;
		i++;
	}
}

t_img		*create_img(void *img, int color, int width, int height)
{
	t_img *s_img;

	if (!(s_img = (t_img*)ft_memalloc(sizeof(t_img))))
		malloc_error();
	s_img->img_ptr = img;
	s_img->data = (int *)mlx_get_data_addr(s_img->img_ptr, &s_img->bpp,
			&s_img->size_line, &s_img->endian);
	fill_img(s_img, color, width, height);
	return (s_img);
}

gradient
#include "fdf.h"

t_gradient	*create_gradient(t_color *beg, t_color *end, t_point *a, t_point *b)
{
	t_gradient	*gradient;
	t_point		*a_cp;
	t_point		*b_cp;

	if (!(gradient = (t_gradient*)ft_memalloc(sizeof(t_gradient))))
		malloc_error();
	gradient->begin = beg;
	gradient->end = end;
	a_cp = copy_point(a);
	b_cp = copy_point(b);
	gradient->nb_pixel = get_nb_pixel(a_cp, b_cp);
	ft_memdel((void**)&a_cp);
	ft_memdel((void**)&b_cp);
	gradient->color = create_color(beg->decimal);
	gradient->step = 1.0 / (float)gradient->nb_pixel;
	gradient->mix = gradient->step;
	return (gradient);
}

void		free_gradient(t_gradient *gradient)
{
	ft_memdel((void**)&gradient->begin);
	ft_memdel((void**)&gradient->end);
	ft_memdel((void**)&gradient->color);
	ft_memdel((void**)&gradient);
}

fdf
#include "fdf.h"

int				get_max_line_size(t_fdf *fdf)
{
	int		max_line_size;
	t_line	*line;

	line = fdf->line;
	max_line_size = 0;
	while (line)
	{
		if (line->size > max_line_size)
			max_line_size = line->size;
		line = line->next;
	}
	return (max_line_size);
}

static t_point	*get_spaces(t_fdf *fdf)
{
	int		max_x;
	int		max_y;
	int		max_line;

	max_x = 0;
	max_y = 0;
	max_line = get_max_line_size(fdf);
	max_x = (WIN_WIDTH / max_line) / 4;
	max_y = max_x;
	return (create_point(max_x, max_y));
}

t_fdf			*create_fdf(t_line *line, int ac, char **av)
{
	t_fdf	*fdf;
	int		y;

	y = WIN_HEIGHT / 2;
	if (!(fdf = (t_fdf*)ft_memalloc(sizeof(t_fdf))))
		malloc_error();
	fdf->mlx = NULL;
	fdf->win = NULL;
	fdf->img = NULL;
	fdf->line = line;
	fdf->spaces = get_spaces(fdf);
	fdf->translation = create_point(0, y);
	fdf->palette = create_palette(ac, av);
	fdf->coef_z = 3;
	return (fdf);
}

event
#include "fdf.h"

int				mlx_key(int keycode, void *param)
{
	t_fdf	*fdf;

	fdf = (t_fdf*)param;
	if (keycode == 53)
		exit(EXIT_SUCCESS);
	return (0);
}

static void		mlx_translation(int keycode, t_fdf *fdf)
{
	if (keycode == 123)
		fdf->translation->x -= 10;
	if (keycode == 124)
		fdf->translation->x += 10;
	if (keycode == 125)
		fdf->translation->y += 10;
	if (keycode == 126)
		fdf->translation->y -= 10;
	mlx_destroy_image(fdf->mlx, fdf->img->img_ptr);
	ft_memdel((void**)&fdf->img);
	fdf->img = create_img(mlx_new_image(fdf->mlx, WIN_WIDTH, WIN_HEIGHT),
			0x212121, WIN_WIDTH, WIN_HEIGHT);
	set_points(fdf);
	draw_points(fdf, create_point(0, 0));
	mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->img->img_ptr, 300, 0);
}

static void		mlx_height_zoom(int keycode, void *param)
{
	t_fdf	*fdf;

	fdf = (t_fdf*)param;
	mlx_destroy_image(fdf->mlx, fdf->img->img_ptr);
	ft_memdel((void**)&fdf->img);
	fdf->img = create_img(mlx_new_image(fdf->mlx, WIN_WIDTH, WIN_HEIGHT),
			0x212121, WIN_WIDTH, WIN_HEIGHT);
	if (keycode == 78)
		fdf->coef_z--;
	if (keycode == 69)
		fdf->coef_z++;
	set_points(fdf);
	draw_points(fdf, create_point(0, 0));
	mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->img->img_ptr, 300, 0);
}

int				mlx_key_pressed(int keycode, void *param)
{
	t_fdf	*fdf;

	fdf = (t_fdf*)param;
	if (keycode == 123 || keycode == 124 || keycode == 125 || keycode == 126)
		mlx_translation(keycode, fdf);
	if (keycode == 78 || keycode == 69)
		mlx_height_zoom(keycode, fdf);
	return (0);
}

int				mlx_zoom(int button, int x, int y, void *param)
{
	t_fdf		*fdf;

	(void)x;
	(void)y;
	fdf = (t_fdf*)param;
	if (button == 4 || button == 5)
	{
		mlx_destroy_image(fdf->mlx, fdf->img->img_ptr);
		ft_memdel((void**)&fdf->img);
		fdf->img = create_img(mlx_new_image(fdf->mlx, WIN_WIDTH, WIN_HEIGHT),
				0x212121, WIN_WIDTH, WIN_HEIGHT);
		if (button == 4)
			set_point(fdf->spaces, fdf->spaces->x + 1, fdf->spaces->y + 1);
		if (fdf->spaces->x > 1)
		{
			if (button == 5)
				set_point(fdf->spaces, fdf->spaces->x - 1, fdf->spaces->y - 1);
		}
		set_points(fdf);
		draw_points(fdf, create_point(0, 0));
		mlx_put_image_to_window(fdf->mlx, fdf->win, fdf->img->img_ptr, 300, 0);
	}
	return (0);
}

error
#include "fdf.h"

void	malloc_error(void)
{
	ft_putstr_fd("error : Malloc failed\n", 2);
	exit(EXIT_FAILURE);
}

void	palette_error(void)
{
	ft_putstr_fd("error: Color must be specified in hexadecimal \
(ex 0xFFFFF)\n", 2);
	exit(EXIT_FAILURE);
}

void	arg_error(void)
{
	ft_putstr_fd("usage: fdf [map_file] [c1] [c2] [c3] [c4] [c5]\n", 2);
	exit(EXIT_FAILURE);
}

void	map_error(void)
{
	ft_putstr_fd("error : Map invalid\n", 2);
	exit(EXIT_FAILURE);
}

void	system_error(void)
{
	perror("error ");
	exit(EXIT_FAILURE);
}

draw
#include "fdf.h"

static int		get_color_gradient(t_gradient *gradient)
{
	if (gradient->begin->decimal == gradient->end->decimal)
		return (gradient->begin->decimal);
	if (gradient->step >= 1)
		return (gradient->end->decimal);
	gradient->color->r = gradient->begin->r + (gradient->end->r -
			gradient->begin->r) * gradient->step;
	gradient->color->g = gradient->begin->g + (gradient->end->g -
			gradient->begin->g) * gradient->step;
	gradient->color->b = gradient->begin->b + (gradient->end->b -
			gradient->begin->b) * gradient->step;
	gradient->color->decimal = (gradient->color->r << 16) + (gradient->color->g
								<< 8) + (gradient->color->b);
	gradient->step += gradient->mix;
	return (gradient->color->decimal);
}

static void		get_err(int err_cpy, int *err, t_segment *seg, t_point *a)
{
	if (err_cpy > seg->d->x * -1)
	{
		*err -= seg->d->y;
		a->x += seg->s->x;
	}
	if (err_cpy < seg->d->y)
	{
		*err += seg->d->x;
		a->y += seg->s->y;
	}
}

int				get_nb_pixel(t_point *a, t_point *b)
{
	int			nb_pixel;
	int			err;
	int			err_cpy;
	t_segment	*seg;

	nb_pixel = 0;
	seg = create_segment(abs(b->x - a->x), abs(b->y - a->y),
			a->x < b->x ? 1 : -1, a->y < b->y ? 1 : -1);
	err = (seg->d->x > seg->d->y ? seg->d->x : (seg->d->y * -1)) / 2;
	while (a->x != b->x || a->y != b->y)
	{
		err_cpy = err;
		get_err(err_cpy, &err, seg, a);
		nb_pixel++;
	}
	free_segment(seg);
	return (nb_pixel);
}

static void		draw_segment(t_point *a, t_point *b, t_fdf *fdf,
		t_gradient *gradient)
{
	int			err;
	int			err_cpy;
	t_segment	*seg;

	seg = create_segment(abs(b->x - a->x), abs(b->y - a->y),
								a->x < b->x ? 1 : -1, a->y < b->y ? 1 : -1);
	err = (seg->d->x > seg->d->y ? seg->d->x : (seg->d->y * -1)) / 2;
	while (a->x != b->x || a->y != b->y)
	{
		if (a->y * WIN_WIDTH + a->x <= WIN_WIDTH * WIN_HEIGHT
				&& a->y * WIN_WIDTH + a->x >= 0)
		{
			if (a->x >= 2350 || a->x < 0)
				fdf->img->data[a->y * WIN_WIDTH + a->x] = 0x212121;
			else
				fdf->img->data[a->y * WIN_WIDTH + a->x] =
					gradient->color->decimal;
		}
		gradient->color->decimal = get_color_gradient(gradient);
		err_cpy = err;
		get_err(err_cpy, &err, seg, a);
	}
	free_segment(seg);
	free_gradient(gradient);
}

void			draw_points(t_fdf *fdf, t_point *tmp)
{
	t_line		*l;
	int			i;

	l = fdf->line;
	while (l)
	{
		i = -1;
		while (++i < l->size)
		{
			set_point(tmp, l->points[i]->x, l->points[i]->y);
			if (i < l->size - 1)
				draw_segment(l->points[i], l->points[i + 1], fdf,
					create_gradient(get_color(fdf, l->values[i]->height),
									get_color(fdf, l->values[i + 1]->height),
									l->points[i], l->points[i + 1]));
			set_point(l->points[i], tmp->x, tmp->y);
			if (l->next)
				draw_segment(l->points[i], l->next->points[i], fdf,
					create_gradient(get_color(fdf, l->values[i]->height),
									get_color(fdf, l->next->values[i]->height),
										l->points[i], l->next->points[i]));
		}
		l = l->next;
	}
	ft_memdel((void**)&tmp);
}

color
#include "fdf.h"

t_color	*get_color(t_fdf *fdf, int n)
{
	t_palette	*palette;

	palette = fdf->palette;
	if (n < 0)
		if (palette->c1)
			return (create_color(palette->c1->decimal));
	if (n == 0)
		if (palette->c2)
			return (create_color(palette->c2->decimal));
	if (n >= 1 && n <= 10)
		if (palette->c3)
			return (create_color(palette->c3->decimal));
	if (n >= 11 && n <= 30)
		if (palette->c4)
			return (create_color(palette->c4->decimal));
	if (n > 30)
		if (palette->c5)
			return (create_color(palette->c5->decimal));
	return (create_color(0xFFFFFF));
}

t_color	*create_color(int decimal)
{
	t_color	*color;

	if (!(color = (t_color*)ft_memalloc(sizeof(t_color))))
		malloc_error();
	color->decimal = decimal;
	color->r = (decimal >> 16) & 0xff;
	color->g = (decimal >> 8) & 0xff;
	color->b = decimal & 0xff;
	return (color);
}